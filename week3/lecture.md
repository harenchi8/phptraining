# 第3週 座学テキスト

## 1. エラー制御とセキュリティ (9/6)

### エラー処理 (try-catch)

プログラム実行中に予期せぬ事態（例: DB接続失敗、ファイルが見つからない）が発生すると、エラーが発生し処理が停止してしまいます。`try-catch`構文を使うと、エラーを検知して代替処理を行う「例外処理」を実装できます。

- **`try`**: エラーが発生する可能性のあるコードをこのブロックで囲みます。
- **`catch (Throwable $e)`**: `try`ブロック内でエラー（例外）が発生すると、実行が`catch`ブロックに移ります。引数`$e`にはエラー情報を持つ`Throwable`オブジェクトが格納されます。
- **`finally`**: `try`や`catch`の処理が終わった後、**必ず**実行される処理を記述します。DBの切断処理など、後始末に適しています。
- **`throw`**: 開発者自身が意図的に例外を発生させたい場合に使います。

```php
<?php
function division($a, $b) {
    if ($b == 0) {
        // 0での除算はエラーなので、意図的に例外を投げる
        throw new Exception("0で割ることはできません。");
    }
    return $a / $b;
}

try {
    echo division(10, 2); // 5
    echo division(5, 0);  // ここで例外が発生
    echo "この行は実行されません";
} catch (Exception $e) {
    // 例外をキャッチした場合の処理
    echo "エラーが発生しました: " . $e->getMessage();
} finally {
    echo "\n処理が終了しました。";
}
?>
```

---

### Webセキュリティの基礎

Webアプリケーションを公開する上で、セキュリティ対策は必須です。ここでは代表的な2つの脆弱性とその対策を学びます。

#### 1. クロスサイトスクリプティング (XSS)

- **概要**: 攻撃者が、脆弱性のあるサイトのフォームなどを通じて、悪意のあるスクリプト（主にJavaScript）を埋め込み、他のユーザーのブラウザ上で実行させる攻撃。
- **影響**: Cookie情報の窃取（なりすまし）、意図しない操作の実行、偽のページ表示など。
- **対策**: **ユーザーからの入力を画面に出力する際は、必ずエスケープ処理を行う。**
    - PHPでは `htmlspecialchars()` 関数を使います。
    - この関数は、`<` `>` `&` `"` などのHTMLで特別な意味を持つ文字を、無害な文字列（エンティティ）に変換します。

**悪い例:**
```php
<?php
  $userInput = $_GET['comment'];
  echo "<div>" . $userInput . "</div>"; // 危険！
?>
```
もし `$userInput` に `<script>alert('XSS');</script>` が入力されると、そのまま実行されてしまいます。

**良い例:**
```php
<?php
  $userInput = $_GET['comment'];
  // htmlspecialcharsでエスケープしてから出力する
  echo "<div>" . htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8') . "</div>";
?>
```
> `ENT_QUOTES`はシングルクォートとダブルクォートの両方を変換するオプション、`UTF-8`は文字コードの指定です。基本的にこのセットで使います。

#### 2. CSRF (クロスサイトリクエストフォージェリ)

- **概要**: 攻撃者が用意した罠サイトなどを通じて、ログイン状態のユーザーに、意図しないリクエスト（例: 商品の購入、退会処理）を強制的に送信させる攻撃。
- **影響**: ユーザーが意図しないうちに、重要な処理を実行させられてしまう。
- **対策**: **正規のフォームから送信されたリクエストであることを確認する仕組みを導入する。**
    1.  **トークンの生成**: フォームを表示する際に、サーバーはランダムで推測困難な文字列（トークン）を生成し、セッションに保存します。
    2.  **トークンの埋め込み**: 生成したトークンを、フォームの `hidden` フィールドに埋め込んでおきます。
    3.  **トークンの検証**: フォームが送信されたら、サーバーは送信されてきたトークンと、セッションに保存しておいたトークンが一致するかどうかを検証します。一致すれば正規のリクエスト、しなければ不正なリクエストとして処理を中断します。

**実装のイメージ:**

**form.php**
```php
<?php
session_start();
// トークンを生成し、セッションに保存
$token = bin2hex(random_bytes(32));
$_SESSION['csrf_token'] = $token;
?>
<form action="submit.php" method="post">
    <!-- hiddenフィールドにトークンを埋め込む -->
    <input type="hidden" name="csrf_token" value="<?= $token ?>">
    <input type="text" name="message">
    <button type="submit">送信</button>
</form>
```

**submit.php**
```php
<?php
session_start();
// 送信されたトークンとセッションのトークンを比較
if (!isset($_POST['csrf_token']) || $_POST['csrf_token'] !== $_SESSION['csrf_token']) {
    die("不正なリクエストです。");
}

// トークンが一致した場合のみ、処理を続行
echo "正規のリクエストとして処理しました。";

// 使用済みのトークンは削除するのが望ましい
unset($_SESSION['csrf_token']);
?>
```

---

## 2. ミニアプリ①：お問い合わせフォーム (9/7)

これまでの知識を総動員して、実践的なアプリケーションを作成します。

### バリデーション付き設計

アプリケーションを作成する際は、まず「要件」を定義し、それに沿って「設計」を行います。

**要件:**
- 名前、メールアドレス、お問い合わせ内容を入力できるフォームがある。
- 送信前に、入力内容のバリデーション（検証）を行う。
- バリデーションエラーがあれば、エラーメッセージと共に元の画面に戻す。
- バリデーションが通れば、確認画面を表示する。
- 確認後、送信完了ページを表示し、管理者（のふりをして）にメールを送信する。

**設計のポイント:**

- **バリデーション**: ユーザーからの入力は信用せず、必ず検証します。
    - **必須チェック**: 空欄でないか (`isset()` や `empty()`, `trim()` を使う)
    - **文字数チェック**: `strlen()` や `mb_strlen()` で長さを確認。
    - **形式チェック**: メールアドレスの形式 (`filter_var($email, FILTER_VALIDATE_EMAIL)`) など。
- **エラーメッセージの表示**: どこで、どのエラーが起きているかユーザーに分かりやすく伝えます。エラー内容をセッションに保存して、入力画面にリダイレクトする方法が一般的です。
- **入力値の再表示**: バリデーションエラーで入力画面に戻った際、正常な入力値はフォームに再表示されているべきです。ユーザーの再入力の手間を省きます。
- **メール送信**: PHPには `mb_send_mail()` という関数がありますが、サーバーの設定が必要でローカル環境では難しいことが多いです。今回は「メールを送信した」という体で、送信内容を画面に表示するだけにします。

```
